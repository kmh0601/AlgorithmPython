'''
점화식을 세우는게 가장 중요하다. 큰 수 부터 생각해서 그 밑의 수는 어쩌지? 그럼 그 밑의 수는? 이런 생각이 꼬리를 문다면
BottomUp 방식을 생각해내는게 좋다. dp[1]은 확실히 채울 수 있고, 그 뒤의 숫자들은 연속해서 나오므로 이를 이용해서 index 1 에서부터 n까지
dp테이블을 채워넣는 방식을 사용하는 것이 좋다. 이 문제의 경우 - 1 을 default 값으로 해서 다른 가능한 경우의 수를 비교하는 방식이다.
default 값ㅇ르 if로 따로 두지 말고 우선 default 값을 저장한 뒤에 다른 값과 if를 통해 비교하는 것이 효율적인 것 같다.
'''

n = int(input())

dp = [0] * 30001

for x in range(2, n+1):
    # 1을 뺀 경우의 횟수
    dp[x] = dp[x-1] + 1

    # 2로 나눠질 경우의 횟수
    if x % 2 == 0:
        dp[x] = min(dp[x],dp[x//2] + 1)

    # 3으로 나눠질 경우의 횟수(elif가 아닌 이유는 2, 3, 5 모두로 나눠질 수도 있기 때문에 그 중 최소값을 찾기 위해서이다.)
    if x % 3 == 0:
        dp[x] = min(dp[x],dp[x//3]+1)

    # 5로 나눠질 경우의 횟수
    if x % 5 == 0:
        dp[x] = min(dp[x], dp[x//5]+1)

print(dp[n])
